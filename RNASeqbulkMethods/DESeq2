
RNA-seq Differential Expression (DE) Analysis Using DESeq2
The original paper from Anders & Huber that introduces the concepts implemented in DESeq2 is available here https://genomebiology.biomedcentral.com/articles/10.1186/s13059-014-0550-8Love, M.I., Huber, W., Anders, S. Moderated estimation of fold change and dispersion for RNA-seq data with DESeq2 Genome Biology 15(12):550 (2014)

We will be using the pasilla package for our example data which is cited here. Wolfgang Huber and Alejandro Reyes (2019). pasilla: Data package with per-exon and per-gene read counts of RNA-seq samples of Pasilla knock-down by Brooks et al., Genome Research 2011.. R package version 1.12.0.

Data for the package is part of this paper: "Conservation of an RNA regulatory map between Drosophila and mammals" by Brooks AN, Yang L, Duff MO, Hansen KD, Park JW, Dudoit S, Brenner SE, Graveley BR, Genome Res. 2011 Feb;21(2):193-202, Epub 2010 Oct 4, PMID: 20921232.

Since we will be using the apeglm shrinkage estimator to create our MA plot, I have also cited those authors
Zhu, A., Ibrahim, J.G., Love, M.I. (2018) Heavy-tailed prior distributions for sequence count data: removing the noise and preserving large differences. Bioinformatics. https://doi.org/10.1093/bioinformatics/bty895

Briefly, DESeq2 uses a Wald test to determine differential gene expression between at least two groups. DESeq2 assumes a negative binomial model which mathematically accounts for the fact that we are assessing gene counts and we are assuming that most genes we are comparing between the groups will not be differentially expressed.

Please note that DESeq2 has a number of capabilities that we will not be covering. You can import data for use in DESeq2 in several different ways, there are options for single cell projects, for incorporating Bayesian statistics, for time-series experiments, for outliers, for obtaining all of the results that DESeq2 functions produce, and even more options for graphing (including an R shiny app we plan to cover in a future walkthrough) so we strongly encourage you to reach out to EICC with questions regarding options available to you with DESeq2.

Definition of terms


######Wald test: DESeq2 offers two options with how it determines differential expression, the Wald test and the Likelihood Ratio Test. Users of edgeR may be familiar with the latter. In DESeq2, the default test for pairwise comparison analysis is called the Wald Test and it is looking at your control and your experimental samples to see if the difference between them is equal to zero or not. Compared to edgeR it has been our experience that DESeq2 is more liberal in its calling of genes as significantly DE. If you are not sure which or how many DE genes you are expecting to find in your experiment, DESeq2 would likely the best analysis tool for your data.

######Shrinkage estimator: Shrinkage estimators help us more accurately measure exactly how much the log transformation is condensing the data as it tends to do, especially when there are very small and very large values in one dataset together. Choosing the best estimator to assess this depends on your experimental aims and what you would like to do with your data but picking one is essential for accurately visualizing data analyzed in DESeq2.

######Unadjusted p values vs adjusted p values/(FDR): In DE analysis, a single p-value tells you how likely it is that a single gene is differentially expressed between at least two groups (ex: a control and a treatment group) due to some actual difference between the groups as opposed to random chance. False Discovery Rate (FDR) tells you how likely it is that all genes identified as DE are false positives. A FDR of 5% means that among all genes called DE, an average of 5% of those are truly not DE. DE genes are only considered significantly so if they meet the adjusted p value, not only the unadjusted p value.
Our very first step is to load the DESeq2 package and the pasilla package from Bioconductor. Please see http://bioconductor.org/ for information about initial installation and use of Bioconductor and its packages.

library("DESeq2")
library("pasilla")

Load our example data
Our example data are from the pasilla package available on Bioconductor. The experiment studied RNAi knockdown of Pasilla, the Drosophila melanogaster ortholog of mammalian NOVA1 and NOVA2, on the transcriptome. Data are provided by NCBI Gene Expression Omnibus under accession numbers GSM461176 to GSM461181.

DESeq2 offers many options for importing count data and data about your samples. Here we will demonstrate importing the count matrix and sample data from the pasilla package.

Please reach out to EICC if you would like to compare 3 or more groups as this is a simplified example. It may also be the case you will need more than 6 samples per experimental group or that you may need to remove genes with average counts greater than 5, 10, 15, or even 20 for sufficient statistical power. Please see our PROPER walkthrough for an example of our of power and sample size analysis.

countdata <- system.file("extdata",
                      "pasilla_gene_counts.tsv",
                      package="pasilla", mustWork=TRUE)
​
countdata <- as.matrix(read.csv(countdata,sep="\t",row.names="gene_id"))
Load the sample data
Next, we import any information we have about our samples. At a minimum, this typically includes a sample id and a group variable though ideally you would include as much information as is available about your samples.

In our case we have an ID variable, a condition variable that denotes being either a treated or an untreated sample, and a type variable that denotes if the sample is paired-end or single-read.

sampledata <- system.file("extdata",
                       "pasilla_sample_annotation.csv",
                       package="pasilla", mustWork=TRUE)
​
sampledata <- read.csv(sampledata, row.names=1)
sampledata <- sampledata[,c("condition","type")]
Our data is almost ready to analyze but first we have to check that the column names of our count data are the same as the row names of our sample data. If this is not true, we cannot proceed.

all(rownames(sampledata) %in% colnames(countdata))
FALSE
Since this is FALSE, we have to make some adjustments to the data by setting the row names of the sample data to be the same as the row names of the sample data while also removing the extra "fb" so that the names are the same.

We use the all statement to check that this has fixed the problem.

rownames(sampledata) <- sub("fb", "", rownames(sampledata))
countdata <- countdata[, rownames(sampledata)]
all(rownames(sampledata) == colnames(countdata))
TRUE
Now that the above is TRUE, we can proceed with more specific preparation for analysis

Preparation for Differential Expression Analysis
In order to preform a pairwise comparison we need to specify some information about our data. In DESeq2 we must create a special object called a DESeqdataset object, here abbreviated as dds. This object takes in the countdata, the sample data, and the variable we would like to compare between the samples as inputs.

Next, we specify that the untreated group is our reference group to which we would like to compare our treated samples.

dds <- DESeqDataSetFromMatrix(countData = countdata,
                              colData = sampledata,
                              design = ~ condition)
​
dds$condition <- relevel(dds$condition, ref = "untreated")
If we had any additional data to add about the samples that we wanted to include in our analysis we would add it next but since this is a simplified example, we are only comparing treated and control samples without taking into account any additional information about them.

Prefilter genes with low counts
Typically we want to ignore genes that have counts of zero across all samples since these are adding statistical noise. We may also want to be more stringent and remove genes with rows that sum to 10, 20 or even 30 or less since these could also be contributing noise.

DESeq2 will also filter genes it deems as low counts automatically when we view the results of our analysis later on. The results will tell you how many genes were removed and how many remain. If you would like to specify your own cut-offs for filtering or if you do not want DESeq2 to do any additional filteirng, you also have those options.

If you choose to do DE analysis through EICC we would customize this part of the analysis based on your data.

Use the DESeq2 analysis pipeline on DESeq2 dataset object
DESeq2's analysis step is quite neat compared to the analysis steps of edgeR and baySeq. It will tell you the steps it is taking with your data and you have the option to ask for additional output and customizations but the default analysis explained here and in the walkthrough from package authors makes those choices behind the scenes.

Finally, we create our results with the results function and use the summary function to see a tabular summary of them. The summary gives you information about the total number of genes with nonzero read counts, the adjusted p value it used to determine significantly DE genes (default is 0.1 but this can be changed in the DESeq function), the exact number and total percentage of the up and down regulated DE genes, the presence of any outliers, and the removal of any additional genes with low counts.

dds <- DESeq(dds)
res <- results(dds)
summary(res)
estimating size factors
estimating dispersions
gene-wise dispersion estimates
mean-dispersion relationship
final dispersion estimates
fitting model and testing

out of 9921 with nonzero total read count
adjusted p-value < 0.1
LFC > 0 (up)       : 518, 5.2%
LFC < 0 (down)     : 536, 5.4%
outliers [1]       : 1, 0.01%
low counts [2]     : 1539, 16%
(mean count < 6)
[1] see 'cooksCutoff' argument of ?results
[2] see 'independentFiltering' argument of ?results

Summarize Results
In our simplified example we see that controlling the adjustedp/FDR threshold at <0.1, we have 1,054 (10.6%) DE genes. Of these, 518 (5.2%) are up regulated and 536 (5.4%) are down regulated. There was 1 outlier gene (0.01%) detected and 1539 genes (16%) with low counts were removed for having counts <6 across all samples. You can view additional explanations of the way outliers are determined and how the filtering was determined by typing ?results.

If your experimental design included a FDR<0.1 you can export your results here and there are options for exporting results including ordering by smallest adjusted p value/FDR for convenience.

Since our aim in doing DE analysis in this example is to have a list of genes to follow up on with lab tests, we might want to use a more stringent significance threshold so instead of 0.1, we will look at those genes with FDR<0.01 and order our results based on smallest adjusted p value/FDR for convenience.

Being able to be more strict with your threshold than you originally intended is usually good and is typically a sign that your study was well powered. It is much better to have the option to lower your threshold further rather than have to increase it because you did not find anything at the threshold you had specified in your initial experimental design. Please reach out to us at EICC if you would like assistance in planning your experimental design for your RNAseq project and in setting appropriate FDR thresholds.

sum(res$padj < 0.01, na.rm=TRUE)
resOrdered <- res[order(res$pvalue),]
572
Our more stringent cutoff has left us with 572 significantly DE genes in the treated samples as compared to the control samples. We could follow up with these with pathway analysis and/or with lab based tests.

In our walkthorugh of edgeR, In our simplified example we see that controlling the adjustedp/FDR threshold at <0.05, we have 695 (9.6%) DE genes. Of these, 358 (4.9%) are up regulated and 337 (4.7%) are down regulated while 7224 (91%) are not significantly differentially expressed. Different analytical tools will often give you slightly different results and DESEq2 may be better for exploratory rather than projects which have specified genes of interest in mind since DESeq2 may allow more false positives into your significant results but it provides you additional tools for evaluating their veracity before following up with a lab test while edgeR is much more strict with potential false positive results.

DESeq2 is able to handle pairwise comparisons as well as comparisons of multiple groups while accounting for any number of prespecified covariates or other variables of interest like sex, age, ethnicity, or batch effects. Here we illustrate a simplified example of a comparison of a control group and a treatment group.If you had an RNA-seq project with EICC this is when we would export the results in a spreadsheet for you.

We customize our analysis based on your data. If you wanted to assess the effects of interactions or look at time-series experiments, this is the point in the analysis that we would do that. DEseq2 is a very flexible package and if you think your project might benefit from analysis with it, we encourage you to contact EICC.

Visualization
DESeq2 offers a number of visualization options to assess your findings and below we have summarized a few examples available to you.

Log transforming counts is essential for plotting principal components and examining sample to sample distances, among other graphs. DESeq2 offers many options for log transformation and all account for the variance in the data to ensure that noise in the data is not contributing to how it graphs. The vst function is the fastest function so for this example we will show just this function. Note that log transformed count data is specifically for graphing only.

Checking the variance across samples
To make sure that analysis so far has estimated variance correctly, we should check the variance across samples using the plotDispEsts function. Here we have colored the genes blue, the estimated fit line red, and the actual fit line black. With fewer counts for a given gene, we would expect to see more variation due to noise and we are attempting to account for that.

options(repr.plot.width=6, repr.plot.height=5)
plotDispEsts(dds, CV="TRUE", genecol="blue", fitcol="red", finalcol="black" )

As we see, in the graph, our variation appears to be stable and as we might expect, as we have higher mean counts, the variation between the samples decreases. If you are checking your own data and do not see a trend like this, do not hesitate to reach out to EICC with questions.

Log transformation with vst
Now we use the vst function to perform a simple log transformation of the samples while maintaining that stable variance. Since we do not need to re-estimate dispersion, we set blind=False. The data transformed by vst will only be used for visualization of clustering results.

restransf<-vst(dds, blind=FALSE)
Log transformation with shrinkage estimation
Log transformation using a shrinkage estimator is the first step to generating interpretable MA plots. In DESeq2's case, you perform this transformation on the DESeq2 dataset object (dds) and specify your outcome of interest and the type of shrinkage estimator you would like to use.

First, we have to get the names of the results in our DESeq2 dataset by calling the results names function. Next, we use the lfcShrink function to perform the transformation. We specify we want to transform the dds object, and we needed the names to specify the second argument, coef=, and this is set to two because our comparison of interest for these graphs is the second name listed, the 'condition_treated_vs_untreated' comparison. We could also have said coef='condition_treated_vs_untreated'.

Next, we specify the type of shrinkage estimator to use. Recall that shrinkage estimators help us more accurately measure exactly how much the log transformation is condensing the data as it tends to do, especially when there are very small and very large values in one dataset together. You can see in the plot of the variance above that there is a line of genes with very very small log transformed counts toward the bottom of the graph. By default this is set to "normal" but here we have chosen "apeglm" to account for these genes with low counts.

Unlike the default normal setting, apeglm preserves the size of large log fold changes rather than condensing them as would be typical with log transformation and it computes s-values which are the DESeq2 equivalent of q-values explored in our "False Discovery Rate Estimation with qvalue" walkthrough.The s-values here (called with svalue=TRUE) tell us how likely it is that a given DE gene is a false positive finding and this will help us narrow down which we would like to follow up with in the lab.

resultsNames(dds)
resLFC <- lfcShrink(dds, coef=2, type="apeglm", svalue=TRUE)
'Intercept' 'condition_treated_vs_untreated'
using 'apeglm' for LFC shrinkage. If used in published research, please cite:
    Zhu, A., Ibrahim, J.G., Love, M.I. (2018) Heavy-tailed prior distributions for
    sequence count data: removing the noise and preserving large differences.
    Bioinformatics. https://doi.org/10.1093/bioinformatics/bty895
PCA plot
To see how much membership in either the control or treatment group contributes to the differences in their genetic expression, we use a PCA plot.

options(repr.plot.width=6, repr.plot.height=6)
plotPCA(restransf, intgroup=c("condition", "type"))

Here we see that 58% of the differences between the samples is due to the fact that there are some true differences in expression between the treated and untreated samples. Since we also had information on whether these were paired-end or single-read samples, we see that only 29% of the differences between the samples is due to being either a paired-end or single-read sample.

This is a great looking PCA plot because it shows that it is our experimental condition that is largely responsible for the variation between the samples rather than noise generated by sequencing, analysis, or some other unaccounted for variable. Since we have additional data on the type of samples sequenced, we can see that this did not affect the differences between the samples to any large extent.

MA plot
The MA plot shows us the condensed log2 fold changes without the noise generated by genes with low counts.

options(repr.plot.width=5, repr.plot.height=5)
plotMA(resLFC,ylim=c(-4,4), main="DE genes between Groups")
thresholding s-values on alpha=0.005 to color points

We see that since we specified svalue=TRUE, it has used the alpha=0.005 threshold for significance to color DE genes as red and non-DE genes as grey. Outlier genes with -4 log2 fold changes are displayed as red triangles

There are many more functions and many more specifications to functions than are used here in order to show a simplified example of one of the tools we use for differential expression analysis. Obtaining specific, actionable, and publication quality results from analysis requires a deeper understanding of your specific data set and we would love the opportunity to discuss these options with you.

While we encourage clients to reach out prior to sequencing so that we can collaborate to design the experiment to answer your specific questions, we look forward to hearing from you at any stage of your RNAseq project. Please find our contact information available here https://www.cores.emory.edu/eicc/about/index.html

sessionInfo()

R version 3.6.0 (2019-04-26)
Platform: x86_64-w64-mingw32/x64 (64-bit)
Running under: Windows 10 x64 (build 18362)

Matrix products: default

locale:
[1] LC_COLLATE=English_United States.1252 
[2] LC_CTYPE=English_United States.1252   
[3] LC_MONETARY=English_United States.1252
[4] LC_NUMERIC=C                          
[5] LC_TIME=English_United States.1252    

attached base packages:
[1] parallel  stats4    stats     graphics  grDevices utils     datasets 
[8] methods   base     

other attached packages:
 [1] pasilla_1.12.0              DESeq2_1.24.0              
 [3] SummarizedExperiment_1.14.1 DelayedArray_0.10.0        
 [5] BiocParallel_1.18.1         matrixStats_0.55.0         
 [7] Biobase_2.44.0              GenomicRanges_1.36.0       
 [9] GenomeInfoDb_1.20.0         IRanges_2.18.1             
[11] S4Vectors_0.22.0            BiocGenerics_0.30.0        

loaded via a namespace (and not attached):
 [1] bit64_0.9-7            jsonlite_1.6           splines_3.6.0         
 [4] Formula_1.2-3          assertthat_0.2.1       latticeExtra_0.6-28   
 [7] blob_1.2.0             GenomeInfoDbData_1.2.1 numDeriv_2016.8-1.1   
[10] RSQLite_2.1.2          pillar_1.4.2           backports_1.1.4       
[13] lattice_0.20-38        glue_1.3.1             bbmle_1.0.20          
[16] uuid_0.1-2             digest_0.6.20          RColorBrewer_1.1-2    
[19] XVector_0.24.0         checkmate_1.9.4        colorspace_1.4-1      
[22] plyr_1.8.4             htmltools_0.3.6        Matrix_1.2-17         
[25] XML_3.98-1.20          pkgconfig_2.0.2        emdbook_1.3.11        
[28] genefilter_1.66.0      zlibbioc_1.30.0        purrr_0.3.2           
[31] xtable_1.8-4           scales_1.0.0           apeglm_1.6.0          
[34] htmlTable_1.13.1       tibble_2.1.3           annotate_1.62.0       
[37] ggplot2_3.2.1          repr_1.0.1             nnet_7.3-12           
[40] lazyeval_0.2.2         survival_2.44-1.1      magrittr_1.5          
[43] crayon_1.3.4           memoise_1.1.0          evaluate_0.14         
[46] MASS_7.3-51.4          foreign_0.8-72         tools_3.6.0           
[49] data.table_1.12.2      stringr_1.4.0          locfit_1.5-9.1        
[52] munsell_0.5.0          cluster_2.1.0          AnnotationDbi_1.46.1  
[55] compiler_3.6.0         rlang_0.4.0            grid_3.6.0            
[58] RCurl_1.95-4.12        pbdZMQ_0.3-3           IRkernel_1.0.2        
[61] rstudioapi_0.10        htmlwidgets_1.3        labeling_0.3          
[64] bitops_1.0-6           base64enc_0.1-3        gtable_0.3.0          
[67] DBI_1.0.0              R6_2.4.0               gridExtra_2.3         
[70] knitr_1.24             dplyr_0.8.3            zeallot_0.1.0         
[73] bit_1.1-14             Hmisc_4.2-0            stringi_1.4.3         
[76] IRdisplay_0.7.0        Rcpp_1.0.2             geneplotter_1.62.0    
[79] vctrs_0.2.0            rpart_4.1-15           acepack_1.4.1         
[82] coda_0.19-3            tidyselect_0.2.5       xfun_0.9              
​
